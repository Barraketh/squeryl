---
layout: default
title: Mapping Scala types to Sql
---


h2. Nullity in Squeryl

The Squeryl counterpart to Null Sql values or column types is *Option[]*

Squeryl supports Scala primitive types (all AnyVal), java.util.Date and String.

Numeric types (Byte, Int, Long, Float, Double) have a default mapping
to the sql type that matches or exceed the bit length of the Scala/Java
representation.

String fields map by default to varchar(128), this can be overriden
by the length property of the *org.squeryl.Column* annotation.


Custom types for wrapping Jdbc types via *org.squeryl.CustomType* are also supported.

+Mixing primitive types and custom types in a same class or same query 
is probably not a good idea+, it should work in theory but is untested.

h2. Primitive types

The main motivation for using primitive types is for performance and symplicity.
If a query returns N rows of objects with M fields primitive types
will cause the the garbage collector to handle of N objects, while 
for custom types it will be N * M.

To use primitive types, simply import org.squeryl.PrimitiveTypeMode._ 
in the scope where database objects and queries are defined :

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[

  import org.squeryl.PrimitiveTypeMode._
  
  class Song(var id: Long, 
             var title: String, 
			 var artistId: Long, 
             var filePath: Option[String], 
			 var year: Int)
  
  from(songs)(s => where(s.title like "%funk%") select(s))  
]]></script>

that's all there is to it.


h2. Custom types

One motivation for using custom wrapper types is to allow fields
to carry meta data along with validation, as in the next example.

Custom field types must inherit one of the subtypes of CustomType in the package
org.squeryl.customtypes, and import the org.squeryl.customtypes.CustomTypesMode._
into the scope where statements are defined.

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[

/**
 * An example of trait that can be mixed into CustomType,
 * to add meta data and validation 
 */
trait Domain[A] {
  self: CustomType =>

  def label: String
  def validate(a: A): Unit
  def value: A

  validate(value)
}

class Age(v: Int) extends IntField(v) with Domain[Int] {
  def validate(a: Int) = assert(a > 0, "age must be positive, got " + a)
  def label = "age"
}

class FirstName(v: String) extends StringField(v) with Domain[String] {
  def validate(s: String) = assert(s.length <= 50, "first name is waaaay to long : " + s)
  def label = "first name"
}

class WeightInKilograms(v: Double) extends DoubleField(v) with Domain[Double] {
  def validate(d:Double) = assert(d > 0, "weight must be positive, got " + d) 
  def label = "weight (in kilograms)"
}

class ReasonOfVisit(v: String) extends StringField(v) with Domain[String] {
  def validate(s:String) = assert(s.length > 1, "invalid visit reason : " + s)
  def label = "reason of visit"
}
]]></script>

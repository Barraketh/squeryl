---
layout: default
title: Getting Started
---

h2. Requirements 

You will need 

* The Scala runtime jar, version 2.8.0.Beta1-RC8
* The Squeryl jar found "here":http://github.com/max-l/Squeryl/downloads
* The CGLIB cglib-nodep-2.2.jar, found "here":http://sourceforge.net/projects/cglib/files/
* A JDBC driver for your database, see "supported databases":./supported-databases.html

If you prefer to build from source with SBT, read "this":http://github.com/max-l/Squeryl/blob/master/readme.txt


h2. Defining a Schema

Scala classes are mapped to tables via instances of org.squeryl.Table[T],
that are grouped in a org.squeryl.Schema singleton.

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[
  import org.squeryl.PrimitiveTypeMode._

  class Author(val id: Long, 
               val firstName: String, 
			   val lastName: String)
  
  // fields can be mutable or immutable 
  
  class Book(val id: Long, 
             var title: String,
			 @Column("AUTHOR_ID") // the default 'exact match' policy can be overriden
			 var authorId: Long,
			 var coAuthorId: Option[Long]) {
    
	def this() = this(0,"",0,Some(0L))
  }
  
  object Library extends Schema {
  
    //When the table name doesn't match the class name, it is specified here :
    val authors = table[Author]("AUTHORS")
	
	val books = table[Book]
  }
  
]]></script>

The org.squeryl.Schema trait can create the Schema or dump the definition to a file.

h2. Mapping fields to Columns

Squeryl applies the principle of _Convention over Configuration_ :
The class to table and field to column correspondance is determined
by name equivalence. It is possible to override a field's column name 
with the org.squeryl.annotations.Column annotations and the class's 
table name table with the org.squeryl.Schema.table[T](tableName:String) 
method. as illustrated in the previous example.

The Column annotation can also be used to redefine default length
for String/varchar columns (and also for other types although it 
should rarely be necessary).

h2. Nullable columns are mapped with Option[] fields

The default (and strongly recommended) way of mapping nullable columns
to fields is with the Option[] type. If you use Squeryl to create
(or generate) your schema, all fields have a not null constraint,
and Option[] fields are nullable.

* *Important* : If a class has an Option[] field, it becomes *mandatory*
  to implement a zero argument constructor that initializes Option[] fields
  with Some() instances (like the Book class in the example above).
  Failing to do so will cause an exception to be thrown
  when the table will be instantiated. The reason for this is that type erasures 
  imposed by the JVM prevents from reflecting on the Option[] type parameter.
  This constraint could be relaxed in a future version by a compiler plugin
  that would _tell_ Squeryl the erased type information.
  
  
h2. Connecting to a Database 

All database interaction is done via a Squeryl session (org.squeryl.Session),
which is just a wrapper over a Jdbc connection, that provides the means
to bind itself to the thread local storage.

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[
  import org.squeryl.PrimitiveTypeMode._

    Class.forName("org.postgresql.Driver");

    val session = 
	  Session.create(
        java.sql.DriverManager.getConnection("jdbc:postgresql://localhost:5432/squeryl", "squeryl", "squeryl"),
        new PostgreSqlAdapter
      )

	//Squeryl database interaction must be done with a using block : 
	using(session) {       
	
	   books.insert(new Author(1, "Michel","Folco"))	   	   
	   val a = from(authors)(a=> where(a.lastName === "Folco") select(a))
	}	    	
]]></script>

The 'using' function binds the session to the current thread for the duration
of the block, so any method called directly or undirectly from the block
will be _in the context_ of the session's connection (and transaction).

h2. Primitive types

The main motivations for using primitive types are for performance and symplicity.
If a query returns N rows of objects with M fields primitive types
will cause the the garbage collector to handle of N objects, while same 
query using custom types will cause the creation of N * M objects.

To use primitive types, simply import org.squeryl.PrimitiveTypeMode._ 
in the scope where database objects and queries are defined :

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[

  import org.squeryl.PrimitiveTypeMode._
  
  class Song(val id: Long, 
             val title: String, 
			 val artistId: Long, 
             val filePath: Option[String], 
			 val year: Int)
  
  from(songs)(s => where(s.title like "%funk%") select(s))  
]]></script>

that's all there is to it.

<a name='disambiguate'></a>

* *important* : in PrimitiveTypes mode there can be ambiguities between numeric operators

When using org.squeryl.PrimitiveTypeMode, the compiler will treat an expression like the 
one in the next example as a Boolean. The .~ function is needed to tell the compiler that the 
left side is a node of TypedExpressionNode[Int] which will cause the whole expression to be a
LogicalBoolean which is what the where clause takes :

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[
    from(songs)(s =>
       where(s.year.~ > 1965)
       select(s)
    )  		
]]></script>		

It is also needed in the following case :

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[
    from(songs)(s =>
      where(s.year.~ + 10 === 1965)
      select(s)
    )
]]></script>

 This is only required when using PrimitiveType mode, with custom types 
there is no ambiguity, since custom types are not (AnyVal) numerics.

A compiler plugin could eventually place .~ in all expression nodes.
An alternative could also be to use other symbols than the 
standard math operators to avoid the ambiguity altogether.
Opinions on this choice/tradeoff would be appreciated.


h2. Custom types

One motivation for using custom wrapper types is to allow fields
to carry meta data along with validation, as in the next example.

Custom field types must inherit one of the subtypes of CustomType in the package
org.squeryl.customtypes, and import the org.squeryl.customtypes.CustomTypesMode._
into the scope where statements are defined.

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[

import org.squeryl.customtypes.CustomTypesMode._
import org.squeryl.customtypes._

/**
 * An example of trait that can be mixed into CustomType,
 * to add meta data and validation 
 */
trait Domain[A] {
  self: CustomType =>

  def label: String
  def validate(a: A): Unit
  def value: A

  validate(value)
}

class Age(v: Int) extends IntField(v) with Domain[Int] {
  def validate(a: Int) = assert(a > 0, "age must be positive, got " + a)
  def label = "age"
}

class FirstName(v: String) extends StringField(v) with Domain[String] {
  def validate(s: String) = assert(s.length <= 50, "first name is waaaay to long : " + s)
  def label = "first name"
}

class WeightInKilograms(v: Double) extends DoubleField(v) with Domain[Double] {
  def validate(d:Double) = assert(d > 0, "weight must be positive, got " + d) 
  def label = "weight (in kilograms)"
}

class Patient(val firstName: FirstName, val age: Age, val weight: WeightInKilograms)

val heavyWeights = from(patients)(p => where(p.weight > 250) select(p))

]]></script>

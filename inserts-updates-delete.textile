---
layout: manual
title: Insert, Update and Delete
---

h2. Insert 

The insert mechanism is the least suprising of all : 

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[

    val herbyHancock = 
	  artists.insert(new Artist("Herby Hancock"))
	  
    val ponchoSanchez = 
	  artists.insert(new Artist("Poncho Sanchez"))
	  
    val theMeters = 
	  artists.insert(new Artist("The Meters"))	
]]></script>

Objects that extend KeyedEntity[K] where K is a numeric type
will have their id field assigned their newly created primary key
value (the mechanism for generating keys is specific to each DatabaseAdaptor).

h2. Update 

There are two forms of updates :

1. Full

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[

  watermelonMan.title = "The Watermelon Man"
  watermelonMan.year = watermelonMan.year + 1  
  songs.update(watermelonMan)
]]></script>


2. Partial :

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[

    update(songs)(s =>
      where(s.title === "Watermelon Man")
      set(s.title := "The Watermelon Man",
          s.year  := s.year.~ + 1)
    )	
]]></script>

(The explanation for the '~' in s.year.~ is "here":./getting-started.html#disambiguate)

The sql will be : 

<script type="syntaxhighlighter" class="brush: sql"><![CDATA[
  update Song set
    title = ?,
    year = (year + ?)
  Where
    (title = ?)
]]></script>


h2. Delete

Delete is done either by key (when objects extend KeyedEntity[K]), or
with a boolean clause via the table's deleteWhere method, 
example of Table[PlaylistElement].deleteWhere usage :

<script type="syntaxhighlighter" class="brush: sql"><![CDATA[

  def removeSong(song: Song) =
    playlistElements.deleteWere(ple => ple.songId === song.id)

  def removeSongOfArtist(artist: Artist) =
    playlistElements.deleteWere(ple =>
      (ple.playlistId === id) and
      (ple.songId in from(songsOf(artist.id))(s => select(s.id)))
    )

]]></script>

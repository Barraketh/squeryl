---
layout: manual
title: Select
---

Select statements return an immutable Query[T] that
is itself a Queryable[T] and a lazy Iterable[T].

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[
 
class Artist(val id: Long, val name:String)  {
   
  def songs = 
    from(MusicDb.songs)(s => where(s.artistId === id) select(s))

}
]]></script>

The lazyness here means that the query is sent to the database only
when starting iteration, or in other words, when Iterable.iterator is called.

The select function takes any legal Scala expression whose
type determins the generic parameter of the <notextile>Query[R]</notextile>

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[
  def select[R](r: =>R): R
]]></script>

The select expression will be evaluated for every row returned by the query.

It is also possible to select with alternative (shorter but less generic) syntax :

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[
class Song(var title: String, var artistId: Long) extends KeyedEntity {
   
  import MusicDb._ // the schema can be imported in the scope
  
  // A shorter syntax for single table queries :
  def artist = artists.where(a => a.id === artistId).single
 
  // lookup by key is available because Artist extends 
  // KeyedEntity[Long] : 
  def lookupArtist = artists.lookup(artistId)
}
]]></script>

Note that the .lookup[K](k: K) i.e. lookup by key method on a Table[T] is only 
available for Table[T] that are of the form : Table[KeyedEntity[K]]

The classes Artist and Song in this example are part of a one to many relation
that can be accessed via the methods.

h2. Nesting

For the next examples, the following query will nested as an inner query 
into other queries :

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[
  def songsInPlaylistOrder =
    from(playlistElements, songs)((ple, s) =>
      where(ple.playlistId === id and ple.songId === s.id)
      select(s)
      orderBy(ple.songNumber asc)
    )
]]></script>

h3. Sub Queries in the From clause :

The from clause takes Queryable[T]'s, a trait of Table[T] View[T] *and* Query[T].
Notice the Query[Song] *funkAndLatinJazz.songsInPlaylistOrder* in the from clause :
 
<script type="syntaxhighlighter" class="brush: scala"><![CDATA[

    val songsFromThe60sInFunkAndLatinJazzPlaylist2 =
      from(funkAndLatinJazz.songsInPlaylistOrder)(s=>
        where(s.id === 123)
        select(s)
      )
]]></script>

h3. Sub Queries in the Where clause :

Joins can also be nested in the where clause just like in SQL :

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[
    val songsFromThe60sInFunkAndLatinJazzPlaylist =
      from(songs)(s=>
        where(s.id in 
		  from(funkAndLatinJazz.songsInPlaylistOrder)
          (s2 => select(s2.id))
		)
        select(s)
      )

    for(s <- songsFromThe60sInFunkAndLatinJazzPlaylist)
      println(s.title + " : " + s.year)
]]></script>

 The Sql generated for the above statement is :

<script type="syntaxhighlighter" class="brush: sql"><![CDATA[
Select
  Song1.year as Song1_year,
  Song1.title as Song1_title,
  Song1.filePath as Song1_filePath,
  Song1.artistId as Song1_artistId,
  Song1.id as Song1_id
From
  Song Song1
Where
 (Song1.id in 
  (Select
     q3.Song5_id as q3_Song5_id
   From
     (Select
        Song5.year as Song5_year,
        Song5.title as Song5_title,
        Song5.filePath as Song5_filePath,
        Song5.artistId as Song5_artistId,
        Song5.id as Song5_id
      From
        PlaylistElement PlaylistElement4,
        Song Song5
      Where
        ((PlaylistElement4.playlistId = ?) and (PlaylistElement4.songId = Song5.id))
      Order By
        PlaylistElement4.songNumber Asc
      )  q3   
  ))

]]></script>

Doing a 3 level nested join is by no means necessary and serves
no other purposes than demonstration.

h2. Select Distinct

Calling the *.distinct* method on a Query[] creates a copy of it that has a 'distinct' select clause :
 
<script type="syntaxhighlighter" class="brush: scala"><![CDATA[
  from(songs)(s => select(&(s.title))).distinct
]]></script>

h2. For Update

Calling the *.forUpdate* method on a Query[] creates a copy of it that has a 'forUpdate' locking directive :
 
<script type="syntaxhighlighter" class="brush: scala"><![CDATA[
  aTable.where(t => t.aField === aValue).forUpdate
]]></script>

<a name='DynamicQuery'></a>

h2. Dynamic Queries

 It is often necessary to create queries with a from clause that varies
with runtime values.

The method *inhibitWhen(b: Boolean)* available on *org.squeryl.Queryable[A]* 
is meant to be called in a from clause, it will turn a Table[A] or (sub) Query[A]
into a Queryable[Option[A]] and remove the queryable from the query
*and all expression containing this queryable.

Example :

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[

    def searchForBooks(authorLastName: Option[String], bookTitle: String) =
      from(authors.inhibitWhen(authorName == None), books)((a,b)=>
        where(a.get.lastName like authorLastName.get and b.title like bookTitle and a.get.id === b.authorId)
        select((b,a))
      )

	val result1:List[(Book,Option(Author))] = searchForBooks(None, "Un Loup est un loup").toList
	
	val result2:List[(Book,Option(Author))] = searchForBooks("Tolstoi", "War and Peace").toList
]]></script>

Notice the Option[] in the result type of the query, and how the Author
table disapears from the generated SQL base on the input of *inhibitWhen* :

<script type="syntaxhighlighter" class="brush: sql"><![CDATA[

  -- first query : searchForBooks(None, "Un Loup est un loup").toList
  
    Select * 
	from 
	  Book b 
	where 
	  b.title like ? -- 'Un Loup est un loup'

  -- second query :	 searchForBooks("Tolstoi", "War and Peace").toList 
  
	Select * 
	from 
	  Author a,
	  Book b
	where 
	  a.lastName like ? and   -- "Tolstoi"
	  b.title like ? and      -- "War and Peace"
	  a.id = b.authorId
]]></script>

h2. Paginated Queries

Paginaged queries are supported via the *page(offset:Int, pageLength:Int)* method on all org.squeryl.Query[A]

Example : 

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[

    def searchForBooks(title : String, offset: Int, pageLength: Int) =
      from(books)(b =>
	    where(b => b.title like title)
		orderBy(b.title asc)
	  ).page(offset, pageLength)
      
    val pageLength = 10
	val page1 = searchForBooks("The Art of%", pageLength * 0, pageLength)
	val page2 = searchForBooks("The Art of%", pageLength * 1, pageLength)
	val page3 = searchForBooks("The Art of%", pageLength * 2, pageLength)
]]></script>

Squeryl uses the appropriate mechanism from the database to paginage efficiently.
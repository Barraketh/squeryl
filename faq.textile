---
layout: default
title: Frequently Asked Questions
---

* *Q: Is Squeryl an ORM or a DSL ?*

* *A*: It is both, however it makes most sense to call it a DSL
  that does 02R mapping. One could also say that it's an
  ORM that has a DSL component, but I prefer the former definition
  because the Sql like DSL aspect is where most of the value is
  added : mapping tables to object is the easy part of the problem,
  allowing application code to write as declaratively as Sql
  while staying within the (intellectual) comfort of the Scala language 
  is the most interesting part.

* *Q: Are relations supported ?*

* *A*: Yes and no !
  There is no concept in Squeryl of relations, but implementing is 
  easily done by reusing the building blocks of the DSL, consider for
  example a "one to many" relation :<br/>
  
<script type="syntaxhighlighter" class="brush: scala"><![CDATA[

    class Song(val id, val title: String, val artistId: Long, val year)  {
	
      def artist = artistsTable.where(a => a.id === artistId).single     
    } 

    class Artist(val id: Long, val name:String)  {
     
      def songs = from(songsTable).where(s => s.artistId === id)
    } 
]]></script>

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[

   for(so <- jamesBrown.songs.where(s => s.year <= 1965))
     println(so.title)
]]></script>

* The 1-M relation is filtered with a condition, and *only one*
query is sent to the database, since jamesBrown.songs
returns an unevaluated Query[Song], which becomes a subquery
when .where(s.year <= 1965) is called on it, and the combined 
query only get's sent to the database for execution when the for iteration begins.
In a JPA style ORM one would either filter the result on the 
client which causes a waste of resources, or define a separate 
query for filtering, loosing the oportunity for reuse.
<br/>
To be fair with JPA, it must be said that not having the concept of 
relations means cascading deletes aren't available. That is 
an area where Squeryl could be enhanced.

* *Q: What kind of caching mechanism is supported ?*

* *A*: No caching mechanism is supported at the moment, however with 
  Scala's lazy val's, a rudimentary (but usefull) form of caching 
  with lazy loading is possible :

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[  
  class Song(val id, val title: String, val artistId: Long)  {
    lazy val artist = artists.where(a => a.id === artistId).single     
  } 
]]></script>

* In this case, aSong.artist would be fetched lazily and only once. 
  
* *Q: There's already a plethora of Java ORMs, do we _really_ need one more ?*

* *A:* Can you spot the typo in this JPA query ?<br/>

<script type="syntaxhighlighter" class="brush: java"><![CDATA[
Query query = 
 em.createQuery( 
   "select a,b,p from authors, books, publisher " +
   "where b.subjectId = :idOfSubject and " +
   "      a.id = b.authorId and " +
   "      b.publiserId = p.id "
 );  
 
 query.setParameter("idOfSubject", idOfSubject);
]]></script>

* let's hope that you can, *because the compiler won't tell you !*
if you happen to rename a column, change it's type, remove it, etc.
the compiler will be of no help.'<br/>
If you use JPAs relation mechanism to _navigate_ through the object graph,
like the following example illustrates, you will regain type safety, 
but at the cost of horrible performance,
*can you count the number of database calls resulting from this JPA query ?*

<script type="syntaxhighlighter" class="brush: java"><![CDATA[  

Iterable<Book> books = bookEntityManager.findBySubjectId(idOfSubject);
while(books.hasNext()) {
  Book b = books.next();
  Author a = b.getAuthor();
  Publisher p = b.getPublisher();
  System.out.println(b.getTitle() + " by " + a.getFullName() + " published by " + p.getName());
}
]]></script>

* The answer is : two database trips for every row returned by the 
findBySubjectId query. <br/>
Squeryl allows you to combine the advantages of the two previous
approaches, *the query is done in a single database call, and you
have type safety*.<br/>

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[  
val q =
  from(authors, books, publisher)((a,b,p) =>
    where(b.subjectId === idOfSubject and
          a.id === b.authorId and
		  b.publisherId === p.id)
    select((a,b,p))
  )
for(r <- q)
  println(r._2.title + " by " + r._1.fullName + " published by " + p._3.name)
]]></script>

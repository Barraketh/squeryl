---
layout: default
title: Group and Agregate Queries
---

Group and Agregate queries, unlike Select queries do not return arbitrary types, but the types : 
Group, Measures and GroupWithMeasures that merely hold tuples. 

Squeryl diverges slightly from Sql in that agregate functions are *not* allowed within a select.
They are instead declared in a 'compute' clause wich is in fact a select in disguise, since
it's arguments end up in the generated Sql select clause. The motivation for this design
choice is to make it a bit harder to write invalid Select statements, since the DSL forces
a 'compute' clause to either replace a select or to follow a groupBy.

As the following example illustrates, the types of the resulting tuples are determined by the 
arguments of the groupBy and compute clause.

|_. Agregate Query Declaration                                                        |_. Query Type                                       |
|  from(aTable)(t=> groupBy(t.aString,t.anInt))                                       |  Query[ *Group*[(String,Int)]]                     |
|  from(aTable)(t=> groupBy(t.aString,t.anIntOption))                                 |  Query[ *Group*[(String,Option[Int])]]             |
|  from(aTable)(t=> compute(min(t.aString),max(t.anInt)))                             |  Query[ *Measures*[(Option[String],Option[Int])]]  |
|  from(aTable)(t=> groupBy(t.aString,t.anInt) compute(max(t.aString),avg(t.anInt)))  |  Query[ *GroupWithMeasures*[(String,Int),(Option[String],Option[Float])]] |


groupBy and compute clauses are mutually exclusive with the select clause in a query,
in other words a query uses either select _or_ a combination of groupBy and compute.

Note how avg(t.anInt) transforms the return type into an Option[Float].
Rules for type conversions are explained in the "Type Mapping":./type-mapping.html section.

 
The groupBy argument list is replicated in the Sql statement's group by clause
and in the select, the compute argument list is appended to the select list
in the generated Sql.

Here is an example, the following Squeryl statement :

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[
  def songCountByArtistId: Query[GroupWithMeasures[Long,Long]] =
    from(artists, songs)((a,s) =>
      where(a.id === s.artistId)
      groupBy(a.id)
      compute(count)
    )
]]></script>

Translates into this Sql statement :

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[
  Select
    Artist1.id as g0,
    count(*) as c0
  From
    Artist Artist1,
    Song Song2
  Where
    (Artist1.id = Song2.artistId)
  Group By
    Artist1.id
]]></script>

Notice how the groupBy(a.id) causes Artist1.id to be in the 
select list _*and*_ in the group by clause, while compute(count)
puts the agregate function 'count' in the select list.


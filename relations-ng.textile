---
layout: manual
title: Relations
---

*Note*: relations are a beta feature, supported only as of version 0.9.4beta

Relations allow a higher abstraction over persistent objects by making foreign key relationships appear as collection like objects. 
There are two types of relations in Squeryl : OneToMany and ManyToMany
 

h3. OneToMany

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[

object SchoolDb extends Schema {

  val courses = table[Course]

  val subjects = table[Subject]  

  val subjectToCourses =
    oneToManyRelation(subjects, courses).
    via((s,c) => s.id === c.subjectId)  
}
  
class Course(val subjectId: Long) extends SchoolDb2Object {

  lazy val subject: OneToMany[Subject] = SchoolDb.subjectToCourses.right(this)
}

class Subject(val name: String) extends SchoolDb2Object {

  lazy val courses: OneToMany[Course] = SchoolDb.subjectToCourses.left(this)
}

]]></script>


The traits OneToMany and ManyToOne both extends Query[], they have an *assign* method 
that assigns the keys while leaving the database unchanged. The *associate* calls assing
*and* persists the changes to the database.

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[
trait OneToMany[M] extends Query[M] {

  /**
   * @param the object on the 'many side' to be associated with this
   *
   *  Sets the foreing key of 'm' to refer to the primary key of the 'one' instance
   */
  def assign(m: M): Unit

  /**
   * Calls 'assign(m)' and persists the changes the database, 
   * by inserting or updating 'm', depending
   * on if it has been persisted or not.
   */
  def associate(m: M): Unit
  
  def deleteAll: Int
}

trait ManyToOne[O] extends Query[O] {

  def assign(one: O): Unit

  def delete: Unit
}
]]></script>


h3. ManyToMany

A ManyToMany relation has a table in the _middle_ called the *association table*, it has a foreing key for the _left_ and _right_ side. It is a symetrical relation, so the choice of left and right is arbitrary. 
In the following example we have a course to student relation, in which the left side is the course and the right side is the student.
The association table can have other fields besides the _left_ and _right_ foeing keys, in the example, *CourseSubscription* has a *grade:Float* column.   

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[

class CourseSubscription(val courseId: Int, val studentId: Int, val grade: Float)

object SchoolDb extends Schema {

  val students = table[Student]

  val courses = table[Course]

  // courseSubscriptions is a ManyToManyRelation, it extends Table[CourseSubscriptions]
  val courseSubscriptions =
    manyToManyRelation(courses, students).
    via[CourseSubscription]((c,s,cs) => (cs.studentId === s.id, c.id === cs.courseId))  
}
  
class Course(val subjectId: Long) extends SchoolDb2Object {

  //students is a ManyToMany[Student,CourseSubscription], it extends Query[Students]
  lazy val students = SchoolDb2.courseSubscriptions.left(this)
}

class Student(val firstName: String, val lastName: String) extends SchoolDb2Object {

  //courses is a ManyToMany[Course,CourseSubscription], it extends Query[Course]
  lazy val courses = SchoolDb2.courseSubscriptions.right(this)  
}

]]></script>


Examples of many to many relation usage :
 
<script type="syntaxhighlighter" class="brush: scala"><![CDATA[

  // the following two lines are equivalent, they both create 
  // and insert a CourseSubscription, with the proper foreing keys : 
  
  physics.students.associate(olga)
    
  olga.courses.associate(physics) 

  //physics.students is a Query[Student] selecting all stutents
  //in the physics course :
  
  println("students of physics :")  
  for(s <- physics.students)
    println(s.fullName)

  // we can get acces the association objects of 
  // a relation member, here we have the CourseSubscription
  // of the physics course :
  physics.students.associations : Query[CourseSubscription]

  // just like for OneToMany, we have the 'assign' methods,
  // that only creates the association object without inserting : 
  val cs:CourseSubscription = olga.courses.assign(physics)

  // cs must be manually inserted for the association to be
  // persistent :   
  SchoolDb.courseSubscriptions.insert(cs)      
  
]]></script>


h4. The trait ManyToMany[O,A] 

<script type="syntaxhighlighter" class="brush: scala"><![CDATA[
trait ManyToMany[O,A] extends Query[O] {

  /**
   * @param a: the association object
   * 
   * Sets the foreing keys of the association object to the primary keys of the left 
   * and right side, this method does not update the database, changes to the association 
   * object must be done for the operation to be persisted. Alternatively the method 
   * 'associate(o, a)' will call this assign(o, a) and persist the changes.  
   */
  def assign(o: O, a: A): Unit

  /**
   * @param a: the association object
   *
   * Calls assign(o,a) and persists the changes the database, by inserting or updating 
   * 'a', depending on if it has been persisted or not.
   */
  def associate(o: O, a: A): Unit

  /**
   * Creates a new association object 'a' and calls assign(o,a)
   */
  def assign(o: O): A

  /**
   * Creates a new association object 'a' and calls associate(o,a)
   *
   * Note that this method will fail if the association object has NOT NULL constraint 
   * fields appart from the foreing keys in the relations
   *  
   */
  def associate(o: O): A

  /**
   *  Deletes all "associations" relating this "side" to the other
   */
  def dissociateAll: Int

  /**
   * a Query returning all of this member's association entries 
   */
  def associations: Query[A]
}

]]></script>
